!/*
program sverif_prep
   use calc_stat_mod, only: calc_filename,calc_read, calc_t1, calc_r, calc_nt,calc_nmembers,calc_var
   use rng_mod, only: rng_t,rng_seed
   implicit none
   !@objective 
   !@description
   !  Calling Sequence:
   !     sverif_prep FIELD_NAME LEVEL HOUR CONTROLE_FILE_NAME OUT_DIRNAME
   !  Control File format
   !     NENTRIES NMEMBERS
   !     MEMBER1_FILE_NAME
   !     MEMBER2_FILE_NAME
   !     ...
   !     ENTRY1_MEMBER_NB LIST_OF_CONTROL_MEMBERS_NB
   !     ENTRY2_MEMBER_NB LIST_OF_CONTROL_MEMBERS_NB
   !     ...
   !  Ouput
   !     3 numbers per line (one per test result)
   !     One line per entry
   !     .FtoR_GZ500_120h.dat
   !*/
#include <msg.h>
#include <arch_specific.hf>
#include <rmnlib_basics.hf>
#include <clib_interface.cdk>

   integer,parameter :: MAX_MEMBERS = 32, LONG_CHAR = 1024, STDOUT = 6, &
        STDERR = 0, NSTAT = 4, T1 = 1, NT1 = 2, NT5 = 3, R = 4

   type :: memberdata_T
      character(len=LONG_CHAR) :: f_S
      real,pointer :: d(:,:,:)
   end type memberdata_T

   character(len=4) :: varname_S
   character(len=LONG_CHAR) :: ctrl_filename_S,out_dirname_S
   integer :: istat,level,hour,nentries,nmembers,nn,ni,nj,niPrev,njPrev
   integer,allocatable :: entries(:,:)
   real :: scale
   real(RDOUBLE) :: exavg0_8,gss0_8
   real, dimension(:,:,:), allocatable :: flds0
   real(RDOUBLE),dimension(:,:),allocatable :: tstat,evar0_8,eavg0_8
   real, dimension(:,:,:), allocatable :: mdata
   type(memberdata_T) :: members(MAX_MEMBERS)
   type(rng_t), dimension(:), allocatable :: rng
   !----------------------------------------------------------------------

   ! Read inputs to program (arguments, control file and data)
   istat = parse_args(varname_S,level,hour,ctrl_filename_S,out_dirname_S)
   if (.not.RMN_IS_OK(istat)) stop
   write(STDOUT,*) trim(varname_S),level,hour,trim(ctrl_filename_S)
   istat = read_control_file(ctrl_filename_S)
   if (.not.RMN_IS_OK(istat)) stop
   write(STDOUT,*) 'nentries, nmembers',nentries,nmembers
   calc_nmembers = nmembers
   do nn=1,nmembers
      write(STDOUT,*) nn,':',trim(members(nn)%f_S)
      istat = min(calc_read(members(nn)%d,members(nn)%f_S,varname_S,level,hour),istat)
      if (.not.RMN_IS_OK(istat)) then
         write(STDERR,*) '(sverif_prep) Error returned by calc_read'
         stop
      endif
      ni = size(members(nn)%d,dim=1); nj = size(members(nn)%d,dim=2)
      if (nn > 1) then
         if (ni /= niPrev .or. nj /= njPrev) then
            write(STDERR,*) '(sverif_prep) Grid dimension mismatch for '//trim(members(nn)%f_S)
            stop
         endif
      endif
      niPrev = ni; njPrev = nj
   enddo

   ! Allocate space based on input sizes
   allocate(tstat(nentries,NSTAT),stat=istat)
   if (istat /= 0) then
      write(STDERR,*) '(sverif_prep) Unable to allocate space for basic variables'
      stop
   endif
   allocate(flds0(ni,nj,nmembers),stat=istat)
   if (istat /= 0) then
      write(STDERR,*) '(sverif_prep) Unable to allocate space for fields'
      stop
   endif
   allocate(rng(nentries),stat=istat)
   if (istat /= 0) then
      write(STDERR,*) '(sverif_prep) Unable to allocate space for pseudorandom numbers'
      stop
   endif

   ! Initialize and write unperturbed estimates
   allocate(eavg0_8(ni,nj),evar0_8(ni,nj),stat=istat)
   evar0_8 = -1.
   if (istat /= 0) then
      write(STDERR,*) '(sverif_prep) Unable to allocate space for first-entry fields'
      stop
   endif
   call rng_seed(rng(1),932118)
   istat = prep_entry(1,evar0_8,0.,rng(1),exavg0_8,eavg0_8,gss0_8,evar0_8,dump=.true.)

   ! Compute test statistics for each sample entry
!$omp parallel private(istat)
!$omp do
   do nn=1,nentries
      call rng_seed(rng(nn),932117+nn)  !create thread-safe random number seeds
      istat = test_entry(nn,evar0_8,scale,rng(nn),tstat(nn,:))
   enddo
!$omp enddo
!$omp end parallel

   ! Create a list of test statistics for each entry
   istat = write_tstat_file(tstat)
   if (.not.RMN_IS_OK(istat)) stop
   !----------------------------------------------------------------------

contains

   !/*
   function parse_args(F_varname_S,F_level,F_hour,F_ctrl_filename_S,F_out_dirname_S) result(F_istat)
      implicit none
      character(len=*),intent(out) :: F_varname_S
      character(len=*),intent(out) :: F_ctrl_filename_S,F_out_dirname_S
      integer,intent(out) :: F_level,F_hour
      integer :: F_istat
      !*/
      character(len=128) :: arg_S
      integer :: mylen,istat
      !----------------------------------------------------------------------
      F_istat = RMN_OK
      call get_command_argument(1,F_varname_S,mylen,istat)
      if (istat /= 0) F_istat = RMN_ERR
      call get_command_argument(2,arg_S,mylen,istat)
     if (istat /= 0) then
         F_istat = RMN_ERR
      else
         read(arg_S,'(i)') F_level
      endif
      call get_command_argument(3,arg_S,mylen,istat)
      if (istat /= 0) then
         F_istat = RMN_ERR
      else
         read(arg_S,'(i)') F_hour
      endif
      call get_command_argument(4,F_ctrl_filename_S,mylen,istat)
      if (istat /= 0) F_istat = RMN_ERR
      call get_command_argument(5,F_out_dirname_S,mylen,istat)
      if (istat /= 0) F_istat = RMN_ERR
      if (.not.RMN_IS_OK(F_istat)) then
         call msg(MSG_ERROR,'(sverif_prep) Wrong args, Usage: sverif_prep VARNAME LEVEL HOUR CTRL_FILENAME OUT_DIRNAME')
      endif
      !----------------------------------------------------------------------
      return
   end function parse_args

   !/*
   function read_control_file(F_filename_S) result(F_istat)
      implicit none
      character(len=*),intent(in) :: F_filename_S
      integer :: F_istat
      !*/
      integer :: istat, fileid, nn
      character(len=128) :: nmembers_S
      character(len=1024) :: fpath
      !----------------------------------------------------------------------
      F_istat = clib_isfile(trim(F_filename_S))
      F_istat = min(clib_isreadok(trim(F_filename_S)),F_istat)
      if (.not.RMN_IS_OK(F_istat)) then
         call msg(MSG_ERROR,'(sverif_prep) Control File not found or not readable: '//trim(F_filename_S))
         return
      endif
      fileid = 0
      F_istat = fnom(fileid,F_filename_S,'SEQ/FMT+R/O+OLD',0)
      if (.not.RMN_IS_OK(F_istat) .or. fileid <= 0) then
         call msg(MSG_ERROR,'(sverif_prep) Problem opening Control file: '//trim(F_filename_S))
         return
      endif

      read(fileid,*,iostat=istat) nentries,nmembers,scale
      if (istat /=0 ) then
         call msg(MSG_ERROR,'(sverif_prep) Problem reading Control file: '//trim(F_filename_S))
         return
      endif
      if (nmembers > MAX_MEMBERS) then
         call msg(MSG_ERROR,'(sverif_prep) Too many members')
         F_istat = RMN_ERR
         return
      endif
      do nn=1,nmembers
         read(fileid,*,iostat=istat) fpath
         if (istat /=0 ) then
            call msg(MSG_ERROR,'(sverif_prep) Problem reading members filenames in Control file: '//trim(F_filename_S))
            F_istat = RMN_ERR
         endif
         do while (index(fpath,':') > 0)
            fpath(index(fpath,':'):index(fpath,':')) = '/'
         enddo
         members(nn)%f_S = trim(fpath)
      enddo

      allocate(entries(nentries,0:nmembers),stat=istat)
      if (istat /= 0) then
         call msg(MSG_ERROR,'(sverif_prep) Problem allocating memory for control file entries')
         F_istat = RMN_ERR
      endif
      write(nmembers_S,'(i)') nmembers
      do nn=1,nentries
         read(fileid,*,iostat=istat) entries(nn,0:nmembers)
         if (istat /=0 ) then
            call msg(MSG_ERROR,'(sverif_prep) Problem reading entries in Control file: '//trim(F_filename_S))
            F_istat = RMN_ERR
            return
         endif
      enddo

      istat = fclos(fileid)
      !----------------------------------------------------------------------
      return
   end function read_control_file


   !/*
   function write_tstat_file(F_tstat) result(F_istat)
      implicit none
      real(RDOUBLE),dimension(:,:),intent(in) :: F_tstat
      integer :: F_istat
      !*/
      integer :: fd,nn
      character(len=1024) :: filename_S,filepath_S
      !----------------------------------------------------------------------
      F_istat = calc_filename(filename_S,'tstat',varname_S,level,hour)
      filepath_S = trim(out_dirname_S)//'/'//trim(filename_S)
      fd = 0
      F_istat = fnom(fd,filepath_S,'SEQ/FMT',0)
      if (.not.RMN_IS_OK(F_istat) .or. fd <= 0) then
         call msg(MSG_ERROR,'(sverif_prep) Problem opening output file: '//trim(filepath_S))
         return
      endif
      do nn=1,size(F_tstat,dim=1)
         write(fd,'(100f)') F_tstat(nn,:)
      enddo
      F_istat = fclos(fd)
      return
    end function write_tstat_file

   !/*
   function write_ens_stats(F_exavg_8,F_eavg_8,F_gss_8,F_evar_8) result(F_istat)
     implicit none
     real(RDOUBLE),intent(in) :: F_exavg_8,F_gss_8
     real(RDOUBLE),dimension(:,:),intent(in) :: F_eavg_8,F_evar_8
     integer :: F_istat
     !*/
     integer :: fd,ii,jj,ni,nj
     character(len=1024) :: filename_S,filepath_S
    !----------------------------------------------------------------------
     F_istat = RMN_OK
     ni = size(F_eavg_8,dim=1)
     nj = size(F_eavg_8,dim=2)
     F_istat = calc_filename(filename_S,'pre',varname_S,level,hour)
     filepath_S = trim(out_dirname_S)//'/'//trim(filename_S)
     fd = 0
     F_istat = fnom(fd,trim(filepath_S),'SEQ/FMT',0)
     write(fd,'(a,2(x,i))') trim(varname_S),level,hour
     write(fd,'(3(i,x))') nmembers,ni,nj
     write(fd,'(2(d,x))') real(F_exavg_8),real(F_gss_8)
     do jj=1,nj
        do ii=1,ni
           write(fd,'(2(i,x),2(d,x))') ii,jj,real(F_eavg_8(ii,jj)),real(F_evar_8(ii,jj))
        enddo
     enddo
     F_istat = fclos(fd)
     return
   end function write_ens_stats

   !/*
   function test_entry(F_entry,F_evar0_8,F_scale,F_rng,F_tstat) result(F_istat)
      use rng_mod, only: rng_t
      implicit none
      integer, intent(in) :: F_entry
      real, intent(in) :: F_scale
      type(rng_t), intent(inout) :: F_rng
      real(RDOUBLE), dimension(:,:), intent(in) :: F_evar0_8
      real(RDOUBLE), dimension(:), intent(out) :: F_tstat
      integer :: F_istat
      !*/
      integer :: err
      real(RDOUBLE) :: exavg_8,gss_8
      real(RDOUBLE), dimension(size(F_evar0_8,dim=1),size(F_evar0_8,dim=2)) :: eavg_8,evar_8
      !----------------------------------------------------------------------
      F_istat = RMN_ERR
      !#      test member number    is in entries(F_entry,0)
      !#      control members list  is in entries(F_entry,1:nmembers)
      F_istat = prep_entry(F_entry,F_evar0_8,F_scale,F_rng,exavg_8,eavg_8,gss_8,evar_8)
      if (F_istat /= RMN_OK) then
         write(STDERR,*) 'Error returned by prep_entry'
         return
      endif
      F_istat = calc_t1(members(entries(F_entry,0))%d(:,:,1),exavg_8,gss0_8,gss_8,F_tstat(T1))
      if (F_istat /= RMN_OK) then
         write(STDERR,*) 'Error returned by calc_t1'
         return
      endif
      F_istat = calc_nt(0.01,members(entries(F_entry,0))%d(:,:,1),eavg_8,evar0_8,evar_8,F_tstat(NT1))
      if (F_istat /= RMN_OK) then
         write(STDERR,*) 'Error returned by calc_nt(1)'
         return
      endif
      F_istat = calc_nt(0.05,members(entries(F_entry,0))%d(:,:,1),eavg_8,evar0_8,evar_8,F_tstat(NT5))
      if (F_istat /= RMN_OK) then
         write(STDERR,*) 'Error returned by calc_nt(5)'
         return
      endif
      F_istat = calc_r(members(entries(F_entry,0))%d(:,:,1),exavg_8,eavg_8,F_tstat(R))
      if (F_istat /= RMN_OK) then
         write(STDERR,*) 'Error returned by calc_r'
         return
      endif
      !----------------------------------------------------------------------
      return
   end function test_entry

   !/*
   function prep_entry(F_entry,F_evar0_8,F_scale,F_rng,F_exavg_8,F_eavg_8,F_gss_8,F_evar_8,dump) result(F_istat)
      implicit none
      integer, intent(in) :: F_entry
      real(RDOUBLE), dimension(:,:), intent(in) :: F_evar0_8
      real, intent(in) :: F_scale
      type(rng_t), intent(inout) :: F_rng
      real(RDOUBLE), intent(out) :: F_exavg_8,F_gss_8
      real(RDOUBLE), dimension(:,:), intent(out) :: F_eavg_8,F_evar_8
      logical, intent(in), optional :: dump
      integer :: F_istat
      !*/
      integer :: imember,ii,jj,ni,nj
      real(RDOUBLE), dimension(size(F_evar_8,dim=1),size(F_evar_8,dim=2),nmembers) :: data
      logical :: myDump
      !----------------------------------------------------------------------
      F_istat = RMN_OK
      myDump = .false.
      if (present(dump)) myDump = dump
      ni = size(F_eavg_8,dim=1)
      nj = size(F_eavg_8,dim=2)

      ! Perturb fields based on a parameteric model
      do imember=1,nmembers
         F_istat = perturb(members(entries(F_entry,imember))%d(:,:,1),F_evar0_8,F_scale,F_rng,data(:,:,imember))
      enddo

      ! Compute the ensemble mean value
      F_exavg_8 = 0.d0
      do imember=1,nmembers
         do jj=1,nj
            do ii=1,ni
               F_exavg_8 = F_exavg_8 + data(ii,jj,imember)
            enddo
         enddo
      enddo
      F_exavg_8 = F_exavg_8/(ni*nj*(nmembers))
      ! Compute the ensemble mean field
      F_eavg_8 = 0.d0
      do imember=1,nmembers
         do jj=1,nj
            do ii=1,ni
               F_eavg_8(ii,jj) = F_eavg_8(ii,jj) + data(ii,jj,imember)
            enddo
         enddo
      enddo
      F_eavg_8 = F_eavg_8/dble(nmembers)
      ! Compute the global sum of squares
      F_gss_8 = 0.d0
      do imember=1,nmembers
         do jj=1,nj
            do ii=1,ni
               F_gss_8 = F_gss_8 + (data(ii,jj,imember) - F_exavg_8)**2
            enddo
         enddo
      enddo
      ! Compute the ensemble variance
      F_evar_8 = 0.d0
      do imember=1,nmembers
         do jj=1,nj
            do ii=1,ni
               F_evar_8(ii,jj) = F_evar_8(ii,jj) + (data(ii,jj,imember) - F_eavg_8(ii,jj))**2
            enddo
         enddo
      enddo
      F_evar_8 = F_evar_8/dble(nmembers)
      ! Dump results for first (ordered) vector
      if (myDump) then
         F_istat = write_ens_stats(F_exavg_8,F_eavg_8,F_gss_8,F_evar_8)
         if (F_istat /= RMN_OK) then
            write(STDERR,*) 'Error returned by write_ens_stats'
            return
         endif
      endif
      !----------------------------------------------------------------------
      return
   end function prep_entry

   function perturb(F_data,F_var_8,F_scale,F_rng,F_perturb_data_8) result(F_istat)
     use rng_mod, only: rng_t,rng_uniform
     ! Select a Gaussian perturbation based on the scaled ensemble variance
     implicit none
     real, dimension(:,:), intent(in) :: F_data
     real(RDOUBLE), dimension(:,:), intent(in) :: F_var_8
     real, intent(in) :: F_scale
     type(rng_t), intent(inout) :: F_rng
     real(RDOUBLE), dimension(:,:), intent(out) :: F_perturb_data_8
     integer :: F_istat
     !*/
     integer :: ii,jj
     real, parameter :: PI=3.14159
     real, dimension(size(F_data,dim=1),size(F_data,dim=2)) :: rnd
     real(RDOUBLE), dimension(size(F_data,dim=1),size(F_data,dim=2)) :: sd_8
     F_istat = RMN_OK

     to_perturb: if (F_scale < epsilon(F_scale)) then
        F_perturb_data_8 = dble(F_data)
     else
        sd_8 = sqrt(F_var_8)
        do jj=1,size(F_data,dim=2)
           do ii=1,size(F_data,dim=1)
              F_perturb_data_8(ii,jj) = F_data(ii,jj) + sd_8(ii,jj) * &
                   dble(F_scale * (3. - 2.*(rng_uniform(F_rng)+rng_uniform(F_rng)+rng_uniform(F_rng))))
           enddo
        enddo
     endif to_perturb
     return
   end function perturb

end program sverif_prep
